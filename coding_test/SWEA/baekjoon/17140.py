"""
크기가 3×3인 배열 A가 있다. 배열의 인덱스는 1부터 시작한다. 1초가 지날때마다 배열에 연산이 적용된다.

R 연산: 배열 A의 모든 행에 대해서 정렬을 수행한다. 행의 개수 ≥ 열의 개수인 경우에 적용된다.
C 연산: 배열 A의 모든 열에 대해서 정렬을 수행한다. 행의 개수 < 열의 개수인 경우에 적용된다.

한 행 또는 열에 있는 수를 정렬하려면, 각각의 수가 몇 번 나왔는지 알아야 한다. 그 다음, 수의 등장 횟수가 커지는 순으로, 그러한 것이 여러가지면 수가 커지는 순으로 정렬한다. 그 다음에는 배열 A에 정렬된 결과를 다시 넣어야 한다. 정렬된 결과를 배열에 넣을 때는, 수와 등장 횟수를 모두 넣으며, 순서는 수가 먼저이다.

예를 들어, [3, 1, 1]에는 3이 1번, 1가 2번 등장한다. 따라서, 정렬된 결과는 [3, 1, 1, 2]가 된다. 다시 이 배열에는 3이 1번, 1이 2번, 2가 1번 등장한다. 다시 정렬하면 [2, 1, 3, 1, 1, 2]가 된다.

정렬된 결과를 배열에 다시 넣으면 행 또는 열의 크기가 달라질 수 있다. R 연산이 적용된 경우에는 가장 큰 행을 기준으로 모든 행의 크기가 변하고, C 연산이 적용된 경우에는 가장 큰 열을 기준으로 모든 열의 크기가 변한다. 행 또는 열의 크기가 커진 곳에는 0이 채워진다. 수를 정렬할 때 0은 무시해야 한다. 예를 들어, [3, 2, 0, 0]을 정렬한 결과는 [3, 2]를 정렬한 결과와 같다.

행 또는 열의 크기가 100을 넘어가는 경우에는 처음 100개를 제외한 나머지는 버린다.

배열 A에 들어있는 수와 r, c, k가 주어졌을 때, A[r][c]에 들어있는 값이 k가 되기 위한 최소 시간을 구해보자.

정리
1. 3x3 배열이 입력된다.
2. r: 행, c: 열, A[r][c]의 원소 값
3. R연산 -> 행 개수 >= 열 개수
4. C연산 -> 행 개수 < 열 개수

제약조건
- 행 또는 열의 크기가 100을 넘어가는 경우에는 처음 100개를 제외한 나머지는 버린다.

"""

from collections import Counter
import numpy as np

# # Counter하면 keys가 원소 종류이고, values가 각 원소의 개수를 나타냄. 이를 dict로 변환가능
# print(Counter(list([1, 2, 3])))
# print(type(Counter(list([1, 2, 3]))))


def r_f(row, col):
    # 정렬 방법: [1, 2, 1], [2, 1, 3], [3, 3, 3] -> 3이 1번, 1이 2번.
    # 첫번째 행 정렬 시작: [1, 2, 1] -> 1이 2번, 2이 1번 -> [2, 1, 1, 2]
    # 두번째 행 정렬 시작: [2, 1, 3] -> 1이 1번, 2가 1번, 3이 1번 -> [1, 1, 2, 1, 3, 1]
    # 세번째 행 정렬 시작: [3, 3, 3] -> 3이 3번 -> [3, 3]
    # 정렬 끝나면, [2, 1, 1, 2], [1, 1, 2, 1, 3, 1], [3, 3]이 되고
    # 가장 원소가 많은 2번 행을 기준으로 나머지 행은 0을 채움 -> [2, 1, 1, 2, 0, 0], [1, 1, 2, 1, 3, 1], [3, 3, 0, 0, 0, 0]




    pass

def c_f(row, col):

    pass

def count_list_elements(l):

    return Counter(l)


if __name__ == "__main__":

    max_time = 100
    time = 0

    r, c, k = map(int, input().split())
    r -= 1
    c -= 1

    a = [list(map(int, input().split())) for i in range(3)]

    # 100번 순회
    while time < max_time:

        if k == a[r][c]:
            break
        else:
            row = len(a)
            col = len(a[0])

            # r연산 조건
            if row >= col:
                r_f(row, col)
            # c연산 조건
            else:
                c_f(row, col)

            # a배열의 행 길이가 100 넘으면 앞에 100개로 초기화
            if len(a) > 100:
                a = a[:100]
            # a배열의 열 길이가 100 넘으면 앞에 100개로 초기화
            if len(a[0]) > 100:
                for i in range(len(a)):
                    a[i] = a[i][:100]


        time += 1


    # 100번 이상했는데 안되면 -1 출력
    if k != a[r][c]:
        print(-1)
    else:
        print(time)



